'''
copyright: Copyright (C) 2015-2021, Wazuh Inc.

           Created by Wazuh, Inc. <info@wazuh.com>.

           This program is free software; you can redistribute it and/or modify it under the terms of GPLv2

type: integration

brief: Wazuh is able to detect vulnerabilities in the applications installed in agents using the Vulnerability Detector
       module. This software audit is performed through the integration of vulnerability feeds indexed by Redhat,
       Canonical, Debian, Amazon Linux and NVD Database.

tier: 0

modules:
    - vulnerability_detector

components:
    - manager

daemons:
    - wazuh-modulesd
    - wazuh-db
    - wazuh-analysisd

os_platform:
    - linux

os_version:
    - Arch Linux
    - Amazon Linux 2
    - Amazon Linux 1
    - CentOS 8
    - CentOS 7
    - CentOS 6
    - Ubuntu Focal
    - Ubuntu Bionic
    - Ubuntu Xenial
    - Ubuntu Trusty
    - Debian Buster
    - Debian Stretch
    - Debian Jessie
    - Debian Wheezy
    - Red Hat 8
    - Red Hat 7
    - Red Hat 6

references:
    - https://documentation.wazuh.com/current/user-manual/capabilities/vulnerability-detection/index.html
    - https://documentation.wazuh.com/current/user-manual/reference/ossec-conf/vuln-detector.html#provider

tags:
    - settings
    - vulnerability
    - vulnerability_detector
    - providers
'''
import os
import pytest

from wazuh_testing.tools import configuration
from wazuh_testing.modules.vulnerability_detector import event_monitor as evm
from wazuh_testing.db_interface import cve_db
from wazuh_testing.modules import vulnerability_detector as vd


pytestmark = [pytest.mark.server]

# Reference paths
TEST_DATA_PATH = os.path.join(os.path.dirname(os.path.realpath(__file__)), 'data')
CONFIGURATIONS_PATH = os.path.join(TEST_DATA_PATH, 'configuration_template')
TEST_CASES_PATH = os.path.join(TEST_DATA_PATH, 'test_cases')
CUSTOM_FEED_PATH = os.path.join(os.path.dirname(os.getcwd()), 'integration', 'test_vulnerability_detector', 'data')

# Configuration and cases data
configurations_path = os.path.join(CONFIGURATIONS_PATH, 'configuration_multiple_provider_feeds.yaml')
test_multiple_providers_cases_path = os.path.join(TEST_CASES_PATH, 'cases_multiple_provider_feeds.yaml')

# Custom feeds path
custom_redhat_oval_feed_path = os.path.join(CUSTOM_FEED_PATH, 'feeds', 'redhat', vd.CUSTOM_REDHAT_OVAL_FEED)
custom_redhat_json_feed_path = os.path.join(CUSTOM_FEED_PATH, 'feeds', 'redhat', vd.CUSTOM_REDHAT_JSON_FEED)
custom_debian_oval_feed_path = os.path.join(CUSTOM_FEED_PATH, 'feeds', 'debian', vd.CUSTOM_DEBIAN_OVAL_FEED)
custom_debian_json_feed_path = os.path.join(CUSTOM_FEED_PATH, 'feeds', 'debian', vd.CUSTOM_DEBIAN_JSON_FEED)

# Test configurations
configuration_parameters, configuration_metadata, test_case_ids = configuration.get_test_cases_data(
    test_multiple_providers_cases_path)
configurations = configuration.load_configuration_template(configurations_path, configuration_parameters,
                                                           configuration_metadata)
# Set offline custom feeds configuration
to_modify = ['CUSTOM_REDHAT_OVAL_FEED_PATH', 'CUSTOM_REDHAT_JSON_FEED_PATH', 'CUSTOM_DEBIAN_OVAL_FEED_PATH',
             'CUSTOM_DEBIAN_JSON_FEED_PATH']
new_values = [custom_redhat_oval_feed_path, custom_redhat_json_feed_path, custom_debian_oval_feed_path,
              custom_debian_json_feed_path]
configurations = configuration.update_configuration_template(configurations, to_modify, new_values)
configuration_metadata = configuration.update_configuration_template(configuration_metadata, to_modify, new_values)


def check_log_events(metadata):
    """Check events in the ossec.log file.

    Args:
        metadata (dict): Metadata from the template.

    Raises:
        ValueError: If the provider in not in the test case dict.
    """
    evm.check_fetching_feed_log(metadata['oval_feed_path'])

    if 'Debian Buster' in metadata['provider_name']:
        evm.check_fetching_feed_log(metadata['json_feed_path'])
        evm.check_refresh_feed_log(metadata['provider_name'])
        evm.check_provider_database_update_finish_log(metadata['provider_name'])
    elif 'Red Hat Enterprise Linux 8' in metadata['provider_name']:
        evm.check_refresh_feed_log(metadata['provider_name'])
        evm.check_provider_database_update_finish_log(metadata['provider_name'])
        evm.check_fetching_feed_log(metadata['json_feed_path'])
        evm.check_refresh_feed_log(metadata['provider_json_name'])
        evm.check_provider_database_update_finish_log(metadata['provider_json_name'])
    else:
        raise ValueError(f"Unexpected {metadata['provider_name']} provider in the test case metadata list")


@pytest.mark.tier(level=0)
@pytest.mark.parametrize('configuration, metadata', zip(configurations, configuration_metadata), ids=test_case_ids)
def test_check_log_multiple_provider_feeds(configuration, metadata, set_wazuh_configuration, truncate_monitored_files,
                                           clean_cve_tables_func, restart_modulesd_function):
    '''
    description: Check if the <path> and <os path=...> options work properly according to the configuration
                 and check there are no conflicts when reading the feeds and inserting them in the database. To do this,
                 it checks that the OVAL feed and JSON feed for a provider has been correctly assigned in the
                 log file.
                 From now on, Redhat and Debian providers use two feeds to fetch vulnerabilities and CVEs' metadata.
                 <os path=...> option indicates the local path where the OVAL feed is whereas <path> indicates the
                 local path where the another feed is. The same goes for <os url=...> and <url> options.

    wazuh_min_version: 4.2.0

    parameters:
        - configuration:
            type: dict
            brief: Wazuh configuration data. Needed for set_wazuh_configuration fixture.
        - metadata:
            type: dict
            brief: Wazuh configuration metadata
        - set_wazuh_configuration:
            type: fixture
            brief: Set the wazuh configuration according to the configuration data.
        - truncate_monitored_files:
            type: fixture
            brief: Truncate all the log files and json alerts files before and after the test execution.
        - clean_cve_tables_func:
            type: fixture
            brief: Clean all the CVE tables before and after running the test.
        - restart_modulesd_function:
            type: fixture
            brief: Restart the wazuh-modulesd daemon.

    assertions:
        - The feed has been fetched.
        - The database has been refreshed successfully.
        - The update of the feed has been finished successfully

    input_description:
        -  The `test_multiple_feeds_provider.yaml` file provides the module configuration for this test.

    expected_output:
        - 'Fetching .* from .*<oval_feed_path>'
        - 'Refresh of <provider_name> database finished'
        - 'The update of the <provider_name> feed finished'
    '''
    check_log_events(metadata)


@pytest.mark.tier(level=5)
@pytest.mark.parametrize('configuration, metadata', zip(configurations, configuration_metadata), ids=test_case_ids)
def test_check_db_multiple_provider_feeds(configuration, metadata, set_wazuh_configuration, truncate_monitored_files,
                                          clean_cve_tables_func, restart_modulesd_function):
    '''
    description: Check if the <path> and <os path=...> options work properly according to the configuration
                 and check there are no conflicts when reading the feeds and inserting in the database. To do this,
                 it checks that the OVAL feed and JSON feed has been correctly assigned in the log file and it checks
                 that the corresponding table of vulnerability database has the elements indexed.
                 From now on, Redhat and Debian providers use two feeds to fetch vulnerabilities and CVEs' metadata.
                 <os path=...> option indicates the local path where the OVAL feed is whereas <path> indicates the
                 local path where the another feed is. The same goes for <os url=...> and <url> options.

    wazuh_min_version: 4.2.0

    parameters:
        - configuration:
            type: dict
            brief: Wazuh configuration data. Needed for set_wazuh_configuration fixture.
        - metadata:
            type: dict
            brief: Wazuh configuration metadata
        - set_wazuh_configuration:
            type: fixture
            brief: Set the wazuh configuration according to the configuration data.
        - truncate_monitored_files:
            type: fixture
            brief: Truncate all the log files and json alerts files before and after the test execution.
        - clean_cve_tables_func:
            type: fixture
            brief: Clean all the CVE tables before and after running the test.
        - restart_modulesd_function:
            type: fixture
            brief: Restart the wazuh-modulesd daemon.

    assertions:
        - The feed has been fetched.
        - The database has been refreshed successfully.
        - The update of the feed has been finished successfully
        - An element of the OVAL feed and an element of JSON feed are present in the corresponding table of the DB.

    input_description:
        - The `test_multiple_feeds_provider.yaml` file provides the module configuration for this test.

    expected_output:
        - 'Starting <provider_name> database update'
        - 'The update of the <provider_name> feed finished'
    '''
    check_log_events(metadata)

    if 'Debian Buster' in metadata['provider_name']:
        json_vuln_str = 'CVE-2012-0833'
        oval_vuln_str = 'CVE-1999-1332'
    elif 'Red Hat Enterprise Linux 8' in metadata['provider_name']:
        json_vuln_str = 'CVE-2013-7488'
        oval_vuln_str = 'CVE-000'
    else:
        raise ValueError(f"Unexpected {metadata['provider_name']} provider in the test case metadata list")

    # Vulnerabilities from OVAL and JSON feeds must be inserted in the corresponding table of the DB
    assert cve_db.check_inserted_value_exists('VULNERABILITIES', 'CVEID', json_vuln_str)

    assert cve_db.check_inserted_value_exists('VULNERABILITIES_INFO', 'ID', oval_vuln_str)
