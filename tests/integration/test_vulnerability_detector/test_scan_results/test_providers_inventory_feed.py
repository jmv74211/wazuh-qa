'''
copyright: Copyright (C) 2015-2021, Wazuh Inc.

           Created by Wazuh, Inc. <info@wazuh.com>.

           This program is free software; you can redistribute it and/or modify it under the terms of GPLv2

type: integration

brief: Wazuh is able to detect vulnerabilities in the applications installed in agents using the Vulnerability Detector
       module. This software audit is performed through the integration of vulnerability feeds indexed by Redhat,
       Canonical, Debian, Amazon Linux and NVD Database.

tier: 1

modules:
    - vulnerability_detector

components:
    - manager

daemons:
    - wazuh-modulesd
    - wazuh-db
    - wazuh-analysisd

os_platform:
    - linux

os_version:
    - Arch Linux
    - Amazon Linux 2
    - Amazon Linux 1
    - CentOS 8
    - CentOS 7
    - CentOS 6
    - Ubuntu Focal
    - Ubuntu Bionic
    - Ubuntu Xenial
    - Ubuntu Trusty
    - Debian Buster
    - Debian Stretch
    - Debian Jessie
    - Debian Wheezy
    - Red Hat 8
    - Red Hat 7
    - Red Hat 6

references:
    - https://documentation.wazuh.com/current/user-manual/capabilities/vulnerability-detection/index.html

tags:
    - settings
    - vulnerability
    - vulnerability_detector
    - scan_results
'''
import os
import pytest

from wazuh_testing.tools import file, configuration
from wazuh_testing.db_interface import agent_db
from wazuh_testing.modules import vulnerability_detector as vd
from wazuh_testing.modules.vulnerability_detector import event_monitor as evm


pytestmark = [pytest.mark.server, pytest.mark.tier(level=1)]

# Reference paths
TEST_DATA_PATH = os.path.join(os.path.dirname(os.path.realpath(__file__)), 'data')
CONFIGURATIONS_PATH = os.path.join(TEST_DATA_PATH, 'configuration_template')
TEST_CASES_PATH = os.path.join(TEST_DATA_PATH, 'test_cases')
FEEDS_PATH = os.path.join(os.path.dirname(os.path.dirname(os.path.realpath(__file__))), 'data', 'feeds')
PACKAGES_PATH = os.path.join(os.path.dirname(os.path.dirname(os.path.realpath(__file__))), 'data',
                             'vulnerable_packages', 'custom_vulnerable_packages.json')

# Configuration and cases paths
configurations_path = os.path.join(CONFIGURATIONS_PATH, 'configuration_providers_inventory_feed.yaml')
test_cases_path = os.path.join(TEST_CASES_PATH, 'cases_providers_inventory_feed.yaml')

# Test configurations
configuration_parameters, configuration_metadata, test_case_ids = configuration.get_test_cases_data(test_cases_path)
configurations = configuration.load_configuration_template(configurations_path, configuration_parameters,
                                                           configuration_metadata)

# Fixture variables
mocked_system = [configuration_metadata[i]['system'] for i in range(len(configuration_metadata))]
vuln_target = [configuration_metadata[i]['target'] for i in range(len(configuration_metadata))]
mocked_packages = file.read_json(PACKAGES_PATH)


def get_feeds_paths_to_modify():
    feed_files = []
    to_modify = []

    for i in range(len(configuration_metadata)):
        try:
            if configuration_metadata[i]['inventory_json_file'] != '':
                feed_files.append(os.path.join(FEEDS_PATH, configuration_parameters[i]['SYSTEM'],
                                  configuration_metadata[i]['inventory_json_file']))
                to_modify.append(configuration_parameters[i]['CUSTOM_JSON_PATH'])
        except: pass
        try:
            if configuration_metadata[i]['inventory_oval_file'] != '':
                feed_files.append(os.path.join(FEEDS_PATH, configuration_parameters[i]['SYSTEM'],
                                  configuration_metadata[i]['inventory_oval_file']))
                to_modify.append(configuration_parameters[i]['CUSTOM_OVAL_PATH'])
        except: pass

    feed_files.append(os.path.join(FEEDS_PATH, 'nvd', vd.CUSTOM_NVD_FEED))
    to_modify.append('NVD_JSON_FEED_PATH')
    

    return feed_files, to_modify

# Set offline custom feeds configuration
custom_feed_paths, to_modify = get_feeds_paths_to_modify()
configurations = configuration.update_configuration_template(configurations, to_modify, custom_feed_paths)


@pytest.fixture(scope='function')
def prepare_inventory_feed_environment(agent_system, mock_agent_with_custom_system, mock_agent_packages_from_variable):
    """Add a mocked agent with mocked packages and force the full scan for that agent.

    Args:
        mock_agent_function (fixture): Fixture thats mocks an agent.
        mock_agent_packages_from_variable (fixture): Fixture that adds mocked packages for mocked agent.
    """
    # Force sync status for packages
    agent_db.update_sync_info(agent_id=mock_agent_with_custom_system, component="syscollector-packages")
    if 'WINDOWS' in agent_system:
        agent_db.update_sync_info(agent_id=mock_agent_with_custom_system, component="syscollector-hotfixes")

    # Force the full scan
    agent_db.update_last_full_scan(1, agent_id=mock_agent_with_custom_system)

    yield mock_agent_with_custom_system


@pytest.mark.parametrize('configuration, metadata, agent_system, vuln_target', zip(configurations,
                         configuration_metadata, mocked_system, vuln_target), ids=test_case_ids)
def test_providers_inventory_feed(configuration, metadata, set_wazuh_configuration, truncate_monitored_files,
                                  clean_cve_tables_func, prepare_inventory_feed_environment,
                                  mock_vulnerabilities_with_custom_system, restart_modulesd_function):
    '''
    description: Check if inserted vulnerable packages are reported by vulnerability detector and correctly inserted
                 into the agent `vuln_cves` table.

    wazuh_min_version: 4.3.0

    parameters:
        - configuration:
            type: dict
            brief: Wazuh configuration data. Needed for set_wazuh_configuration fixture.
        - metadata:
            type: dict
            brief: Wazuh configuration metadata.
        - set_wazuh_configuration:
            type: fixture
            brief: Set the wazuh configuration according to the configuration data.
        - truncate_log_files:
            type: fixture
            brief: Truncate the log files at the end of the testing case.
        - truncate_alert_files:
            type: fixture
            brief: Truncate the alert files at the end of the testing case.
        - clean_cve_tables_func:
            type: fixture
            brief: Clean all tables of the CVE database before and after finishing the test.
        - prepare_inventory_feed_environment:
            type: fixture
            brief: Add a mocked agent with mocked packages and force the full scan for that agent.
        - restart_modulesd_function:
            type: fixture
            brief: Restart the wazuh-modulesd daemon.

    assertions:
        - Verify that the vulnerabilities logs appears in the `ossec.log` file.
        - Verify that the vulnerabilities alerts appears in the `alerts.json` file.
        - Verify that the vulnerabilities are inserted correctly.
        - Verify that the expected vulnerabilities have the status 'VALID'

    input_description:
        - The `configuration_archlinux_inventory.yaml` file provides the module configuration for this test.

    expected_output:
        - f"The '{package}' package .* from agent .* is vulnerable to '{cve}'"
        - f"Package '{package_name}' inserted into the vulnerability '{package_cve}'."
        - f"{cve} affects {package}"
        - "A full scan will be run on agent '000'"
        - "Finished vulnerability assessment for agent '000'"
    '''
    # Number of inserted vulnerabilities
    n_vulns = 0
    for package_inserted in mocked_packages:
        n_vulns += 1
        evm.check_vulnerability_affects_log(package=package_inserted['name'], cve=package_inserted['cveid'],
                                            agent_id=prepare_inventory_feed_environment)
        evm.check_vulnerability_scan_inserted_package(package_name=package_inserted['name'],
                                                      package_cve=package_inserted['cveid'])
        evm.check_vulnerability_affects_alert(package=package_inserted['name'], cve=package_inserted['cveid'],
                                              agent_id=prepare_inventory_feed_environment)

    # Wait for the full scan
    evm.check_vulnerability_full_scan_start(agent_id=prepare_inventory_feed_environment)
    evm.check_vulnerability_full_scan_end(agent_id=prepare_inventory_feed_environment)

    # Check if the inventory count of valid entries is the expected
    valid_inventory_count = agent_db.count_valid_inventory_vulnerabilities(agent_id=prepare_inventory_feed_environment)

    assert valid_inventory_count == n_vulns, f"'VALID' vulnerabilities count: {valid_inventory_count}. It does not " \
                                             f" match with the expected: {n_vulns}"
