'''
copyright: Copyright (C) 2015-2021, Wazuh Inc.

           Created by Wazuh, Inc. <info@wazuh.com>.

           This program is free software; you can redistribute it and/or modify it under the terms of GPLv2

type: integration

brief: Wazuh is able to detect vulnerabilities in the applications installed in agents using the Vulnerability Detector
       module. This software audit is performed through the integration of vulnerability feeds indexed by Redhat,
       Canonical, Debian, Amazon Linux and NVD Database.

tier: 1

modules:
    - vulnerability_detector

components:
    - manager

daemons:
    - wazuh-modulesd
    - wazuh-db
    - wazuh-analysisd

os_platform:
    - linux

os_version:
    - Arch Linux
    - Amazon Linux 2
    - Amazon Linux 1
    - CentOS 8
    - CentOS 7
    - CentOS 6
    - Ubuntu Focal
    - Ubuntu Bionic
    - Ubuntu Xenial
    - Ubuntu Trusty
    - Debian Buster
    - Debian Stretch
    - Debian Jessie
    - Debian Wheezy
    - Red Hat 8
    - Red Hat 7
    - Red Hat 6

references:
    - https://documentation.wazuh.com/current/user-manual/capabilities/vulnerability-detection/index.html

tags:
    - settings
    - vulnerability
    - vulnerability_detector
    - scan_results
'''
import os
import pytest

from wazuh_testing.tools import file
from wazuh_testing.tools import configuration
from wazuh_testing.db_interface import cve_db, agent_db
from wazuh_testing.modules import vulnerability_detector as vd
from wazuh_testing.modules.vulnerability_detector import event_monitor as evm


pytestmark = [pytest.mark.server, pytest.mark.tier(level=1)]

# Fixture variables
mocked_system = 'ARCH'

# Reference paths
TEST_DATA_PATH = os.path.join(os.path.dirname(os.path.realpath(__file__)), 'data')
CONFIGURATIONS_PATH = os.path.join(TEST_DATA_PATH, 'configuration_template')
TEST_CASES_PATH = os.path.join(TEST_DATA_PATH, 'test_cases')
CUSTOM_FEEDS_PATH = os.path.join(os.path.dirname(os.path.dirname(os.path.realpath(__file__))), 'data', 'feeds')

# Configuration and cases data
configurations_path = os.path.join(CONFIGURATIONS_PATH, 'configuration_archlinux_inventory.yaml')
test_cases_path = os.path.join(TEST_CASES_PATH, 'cases_archlinux_inventory.yaml')
custom_arch_feed_path = os.path.join(CUSTOM_FEEDS_PATH, vd.CUSTOM_ARCHLINUX_JSON_FEED)
custom_nvd_feed_path = os.path.join(CUSTOM_FEEDS_PATH, vd.CUSTOM_NVD_FEED)

# Inventory feed configuration
configuration_parameters, configuration_metadata, test_case_ids = configuration.get_test_cases_data(test_cases_path)
configurations = configuration.load_configuration_template(configurations_path, configuration_parameters,
                                                           configuration_metadata)

# Get custom vulnerabilities
vulnerabilities = file.read_json(custom_arch_feed_path)

# Set offline custom feeds configuration
to_modify = ['ARCH_CUSTOM_FEED', 'NVD_JSON_PATH']
new_values = [custom_arch_feed_path, custom_nvd_feed_path]
configurations = configuration.update_configuration_template(configurations, to_modify, new_values)
configuration_metadata = configuration.update_configuration_template(configuration_metadata, to_modify, new_values)

@pytest.fixture
def clean_dbs(metadata):
    agent_db.clean_sys_programs()
    cve_db.clean_all_cve_tables()
    agent_db.clean_vulnerabilities_inventory()

    yield

    agent_db.clean_sys_programs()
    cve_db.clean_all_cve_tables()
    agent_db.clean_vulnerabilities_inventory()


@pytest.fixture
def insert_packages(metadata):
    for vulnerability in vulnerabilities:
        agent_db.insert_package(name=vulnerability['packages'][0], version=vulnerability['affected'], source='NULL')


@pytest.mark.parametrize('configuration, metadata', zip(configurations, configuration_metadata), ids=test_case_ids)
def test_arch_linux_inventory_feed(configuration, metadata, set_wazuh_configuration, truncate_log_files,
                                   truncate_alert_files, restart_modulesd_function, clean_dbs,  mock_system, insert_packages):
    '''
    description: Check if inserted vulnerable packages are reported by vulnerability detector and correctly inserted
                 into the agent `vuln_cves` table.

    wazuh_min_version: 4.3.0

    parameters:
        - configuration:
            type: dict
            brief: Wazuh configuration data. Needed for set_wazuh_configuration fixture.
        - metadata:
            type: dict
            brief: Wazuh configuration metadata.
        - set_wazuh_configuration:
            type: fixture
            brief: Set the wazuh configuration according to the configuration data.
        - truncate_log_files:
            type: fixture
            brief: Truncate the log files at the end of the testing case.
        - truncate_alert_files:
            type: fixture
            brief: Truncate the alert files at the end of the testing case.
        - restart_modulesd_function:
            type: fixture
            brief: Restart the wazuh-modulesd daemon.
        - prepare_arch_environment:
            type: fixture
            brief: Setup the initial test state and clean after the execution.

    assertions:
        - Verify that the vulnerabilities logs appears in the `ossec.log` file.
        - Verify that the vulnerabilities alerts appears in the `alerts.json` file.
        - Verify that the vulnerabilities are inserted correctly.
        - Verify that the expected vulnerabilities have the status 'VALID'

    input_description:
        - The `configuration_archlinux_inventory.yaml` file provides the module configuration for this test.

    expected_output:
        - f"The '{package}' package .* from agent .* is vulnerable to '{cve}'"
        - f"Package '{package_name}' inserted into the vulnerability '{package_cve}'."
        - f"{cve} affects {package}"
        - "A full scan will be run on agent '000'"
        - "Finished vulnerability assessment for agent '000'"
    '''
    # Number of inserted vulnerabilities
    n_vulns = len(vulnerabilities[0]['issues'])+len(vulnerabilities[1]['issues'])

    # Force full scan
    agent_db.update_last_full_scan(1)

    # Check the vulnerabilities of inserted packages
    for vulnerability in vulnerabilities:
        package = vulnerability['packages'][0]
        for issue in vulnerability['issues']:
            evm.check_vulnerability_scan_log(package=package, cve=issue)
            evm.check_vulnerability_scan_inserted_package(package_name=package, package_cve=issue)
            evm.check_vulnerability_scan_alert(package=package, cve=issue)

    # Wait for the full scan
    evm.check_vulnerability_full_scan_start()
    evm.check_vulnerability_full_scan_end()

    # Check if the inventory count of valid entries is the expected
    valid_inventory_count = agent_db.count_valid_inventory_vulnerabilities()

    assert valid_inventory_count == n_vulns, f"'VALID' vulnerabilities count: {valid_inventory_count}. It does not " \
                                             f" match with the expected: {n_vulns}"
